---
title: "计算机组成原理 — 计算机的运算方法"
subtitle: "计算机科学是一门关于‘计算’的科学，它研究如何用数学的方式描述解决问题的过程！"
layout: post
author: "luobr"
header-style: text
tags:
  - 计算机组成原理
  - 计算机的运算方法
  - 笔记
---

## 计算机的运算方法
### 无符号数和有符号数
#### 概念

计算机中的数均放在寄存器中，通常称寄存器的位数为机器字长。所谓无符号数，即没有符号的数，在寄存器中的每一位均可用来存放数值。当存放有符号数时，则需留出位置存放符号。因此，在机器字长相同时，无符号数与有符号数所对应的数值范围是不同的

比如：以机器字长为16位为例，无符号数的表示范围为 0~65535，而有符号数的表示范围为  -32768 ~ +32767

---

#### 有符号数

##### 有符号数又分真值和机器数

有正负符号（+、-）就是真值，用数字表示符号的就是机器数

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240312185640448.png" alt="image-20240312185640448" style="zoom:67%;" />  

---

##### 原码表示法

原码是机器数中最简单的一种表示形式，符号位为0表示正数，符号位为1表示负数，数值位即真值的绝对值，故原码表示又称为**带符号的绝对值表示**

**整数的原码定义（n 为数值位数）**

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240312190056513.png" alt="image-20240312190056513" style="zoom:67%;" />  

**举例如下**

- 真值： x = +1110   [x]原 = 0,1110 (逗号是用来间隔符号和数值)
- 真值： x = -1110   [x]原 = 1,1110

**小数的原码定义**

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240312190201306.png" alt="image-20240312190201306" style="zoom:67%;" />  

**举例如下**

- 真值： x = +0.1110   [x]原 = 0,1110  (逗号是用来间隔符号和数值)
- 真值： x = -0.1110   [x]原 = 1,1110 

原码的特点是简单、直观，但是不易于进行加减法操作，引出补码

---

##### 补码表示法

易于进行加减法操作（原理：就好比时钟顺时针旋转90度和逆时针旋转270度是没有区别的，可以把减法运算变成加法运算来简化）

**整数的补码定义（n 为数值位数）**

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240312190725110.png" alt="image-20240312190725110" style="zoom:80%;" />   

**举例如下**

- 真值： x = +1110   [x]原 = 0,1110  [x]补 = 0,1110  (逗号是用来间隔符号和数值)
- 真值： x = -1110   [x]原 = 1,1110   [x]补 = 1,0010（计算方式可以将 2^(n+1) 也就是这里的 100000，先进行减1操作，变成 11111 进行加 x 操作，最后加回 1，就好得到最终的结果）

**小数的补码定义**

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240312191511882.png" alt="image-20240312191511882" style="zoom:80%;" />  

**举例如下**

- 真值： x = +0.1110   [x]原 = 0,1110  [x]补 = 0,1110   (逗号是用来间隔符号和数值部分)
- 真值： x = -0.1110   [x]原 = 1,1110   [x]补 = 1,0010

**原码求补码的快捷方式**

- 当原码为正数时，补码和原码是一致的
- 当原码为负数时，补码可用原码（除符号位）每位都取反并末位加上1求得（补码转化成原码也是同样的规则）

----

##### 反码表示法

反码通常用来作为由原码求补码或者由补码求原码的中间过渡

**整数的反码定义（n 为数值位数）**

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240312191714052.png" alt="image-20240312191714052" style="zoom:67%;" />  

**举例如下** 

- 真值： x = +1110   [x]原 = 0,1110  [x]补 = 0,1110   [x]反 = 0,1110(逗号是用来间隔符号和整数数值)
- 真值： x = -1110   [x]原 = 1,1110   [x]补 = 1,0010  [x]反 = 1,0001

**小数的反码定义**

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240312191915009.png" alt="image-20240312191915009" style="zoom:80%;" />  

**举例如下**

- 真值： x = +0.1110   [x]原 = 0.1110  [x]补 = 0.1110  [x]反 = 0.1110
- 真值： x = -0.1110   [x]原 = 1.1110   [x]补 = 1.0010  [x]反 = 1.0001

 **练习题目**

```
x = +70   [x]原 = 0,1000110  [x]补 =  0,1000110
x = -70   [x]原 = 1,1000110  [x]补 =  1,0111010
x = +0.1110   [x]原 = 0.1110  [x]补 = 0.1110
x = -0.1110   [x]原 = 1.1110  [x]补 = 1.0010
x = +0.0000   [x]原 = 0.0000  [x]补 = 0.0000 [x]反 = 0.0000 
x = -0.0000   [x]原 = 1.0000  [x]补 = 0.0000（[+0]补 = [-0]补） [x]反 = 1.1111（[+0]反 != [-0]反）
x = -1.0000   [x]原 = 不能表示  [x]补 = 1.0000 （10.0000 - 1.0000）
```

##### 三种机器数的特点

- 三种机器数的最高位均为符号位。符号位和数值部分之间可用 “,” 隔开
- 当真值为正时，原码、补码和反码的表示形式均相同，即符号位用“0”表示，数值部分与真值相同
- 当真值为负时，原码、补码和反码的表示形式不同，但其符号位都用“1”表示，而数值部分有这样的关系，即补码是原码的“求反加1”，反码是原码的“每位求反”

----

##### 移码表示法

补码表示很难比较数字的大小

**整数的移码定义（x 为真值）**

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240312192123253.png" alt="image-20240312192123253" style="zoom:50%;" /> 

**补码和移码之间的转换**

补码和移码就是符号之间取反，其他都是相同的

注意：移码标志中零也是唯一的



### 数的定点表示和浮点表示

在计算机中，小数点不用专门的器件表示，而是按约定的方式标出，共有两种方法表示小数点的存在，即定点表示和浮点表示

#### 定点表示

- 当小数点位于数符和第一数值位之间时，机器内的数为纯小数
- 当小数点位于数值位之后时，机器内的数为纯整数。
- 采用定点数的机器称为定点机
- 由于小数点的位置固定不变，故当机器处理的数不是纯小数或纯整数时，必须乘上一个比例因子，否则会产生“溢出”

![image-20240316110035878](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240316110035878.png)  、

**应用场景**：通常用于对精度要求不是特别高的计算，比如音频处理、简单的数值计算等

---

#### 浮点表示

浮点数即小数点的位置可以浮动的数（可以理解为科学计数法的引申）

**浮点数表示法：S 为尾数（可正可负），j 为阶码（可正可负），r 是基数（或基值）**

![image-20240316110737288](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240316110737288.png) 

**浮点数转换示例**

![image-20240316111243257](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240316111243257.png)  

**浮点数在机器中的形式如下所示**

采用这种数据格式的机器称为浮点机

- 阶码是整数，阶符和阶码的位数合起来反映浮点数的表示范围及小数点的实际位置
- 尾数是小数，其位数n反映了浮点数的精度
- 尾数的符号代表浮点数的正负

![image-20240316111339340](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240316111339340.png)
**浮点数表示的范围**

以通式 N=S×r^j 为例，设浮点数阶码的数值位取 m 位，尾数的数值位取 n 位，当浮点数为非规格化数时，它在数轴上的表示范围如下

![image-20240316113449175](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240316113449175.png) 

**浮点数的规格化形式**

- 基数 r = 2 尾数最高位为1
- 基数 r = 4 尾数最高2位为不全为0
- 基数 r = 8 尾数最高3位为不全为0

基数越大，可表示的浮点数的范围越大，但是浮点数的精度降低

**机械零**

- 当浮点数尾数为0时，不论其阶码为何值都当机械零处理
- 当浮点数阶码等于或者小于它所表示的最小数时，不论尾数为何值都当机械零处理

**应用场景**：适用于需要大范围数值表示和较高精度的场合，如科学计算、图形渲染等



### 定点运算

#### 移位运算

移位运算称为移位操作，对计算机来说，有很大的实用价值。例如，当某计算机没有乘（除）法运算线路时，可以采用移位和加法相结合，实现乘（除）运算

#### 算数移位规则

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240318191558049.png" alt="image-20240318191558049" style="zoom:67%;" /> 

**算术移位和逻辑移位的区别？**

本质区别：符号位是否参与运算

- 有符号数的移位称为算术移位
- 无符号数的移位称为逻辑移位

算术左移时，符号位移至C,最高数位就可避免移丢

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240318191834589.png" alt="image-20240318191834589" style="zoom:67%;" />  

#### 加法与减法运算

**补码加减运算的基本公式**

- 加法                                                                                                                

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319124136519.png" alt=" " style="zoom: 67%;" />  

- 减法

  <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319124200649.png" alt="image-20240319124200649" style="zoom:67%;" /> 

**举例**

已知 A = 0.1011，B = -0.0101，求[A+B]补

![image-20240319124328601](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319124328601.png)  

**一位符号位溢出判断**

参加操作的两位数符号相同，但是相加或者相减得出符号不同的结果，即为溢出 

硬件实现：通过判断最高有效位 **异或** 符号位的进位 = 1 

**举例**

在这个例子中，两个正数相加，结果却得到了一个负数（符号位为1）。这是不可能的，因为两个正数相加的结果应该是正数。因此，我们可以判断发生了正溢出

```txt
  01111111  (第一个数)
+ 01111111  (第二个数)
  -----------
  10111110  (结果)
```

**二位符号位溢出判断**

结果的双符号位相同 未溢出，反之溢出 比如： 01.xxx ；10.xxxx (最高符号位代表其真实的符号)

![image-20240319124501376](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319124501376.png)  

**举例**

在这个例子中，两个正数相加，结果的双符号位变成了01，这表示发生了正溢出。因为双符号位的第一位是0，表示原来的数值是正数，而第二位是1，表示发生了正溢出

```txt
  00 11111111 11111111  (第一个数)
+ 00 00000000 00000001  (第二个数)
  -------------------
  01 00000000 00000000  (结果)
```

---

#### 乘法运算

乘法运算可以用移位和加法来实现

**示例**

已知x = -0.1110  y = -0.1101，求[x·y]原 = 0.1011 0110（符号异或得到）		

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319125457391.png" alt="image-20240319125457391" style="zoom:67%;" /> 

---

#### 除法运算

##### 概述

**笔算除法和机器除法之间的区别**

|                笔算除法                 |                机器除法                |
| :-------------------------------------: | :------------------------------------: |
|              商符单独处理               |             符号位异或得出             |
|                心算上商                 | \|x\| - \|y\| > 0 上商 1 ，反之上商 0  |
| 余数不动，低位补 0 减去，右移一位的除数 |     余数左移一位低位补 0 减去除数      |
|     2 倍字长加法器，上商位置不固定      | 1 倍字长加法器，在寄存器的末尾进行上商 |

**原码的除法示例**

[x] 原 = x0 * x1 * x2 ... xn  （绝对值标记为 x*）

[y] 原 = y0 * y1 * y2 ... yn  （绝对值标记为 y*）

**约定**

- 小数定点除法 x* < y* => 反之溢出
- 整数定点除法 x* > y* => 反之溢出
- 被除数不能等于 0  => 异常
- 除数不能为 0 => 直接求得 0

##### 恢复余数法

恢复余数法的特点是：当余数（被除数）为负时，需加上除数，将其恢复成原来的余数。

案例如下：

已知 x = - 0.1011，y = -0.1101，求[x/y]原

![image-20231015112934573](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20231015112934573.png) 

##### 加减交替法（不恢复余数法）

**运算规则：**

- 余数 R > 0 上商 1，2R - y* (余数R左移一位，加上 [-y*])
- 余数 R < 0 上商 0，2R + y* (恢复余数R+y*，左移一位 2(R+y *) ，加上 [-y *] 得出 2R + y *)	

案例如下：

已知 x = - 0.1011，y = 0.1101，求[x/y]原

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20231015112840632.png" alt="image-20231015112840632"  />  



### 浮点运算

#### 浮点数的加减运算

![ ](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319185340146.png) 

**运算步骤**

- 对阶，使两数的小数点位置对齐。（小阶向大阶看齐）

- 尾数求和，将对阶后的两尾数按定点加减运算规则求和（差）。

- 规格化，为增加有效数字的位数，提高运算精度，必须将求和（差）后的尾数规格化。

  - 左规：尾数左移一位，阶码减1，直到第一数位和数符不同为止
  - 右规：当尾数溢出时，需要尾数右移一位，阶码加1

- 舍入，为提高精度，要考虑尾数右移时丢失的数值位。

  - 0 舍 1 入法（“0舍1入”法类似于十进制数运算中的“四舍五人”法，即在尾数右移时，被移去的最高数值位为0，则舍去；被移去的最高数值位为1，则在尾数的末位加1）
  - 恒置 1 法（尾数右移时，不论丢掉的最高数值位是“1”或“0”，都使右移后的尾数末位恒置“1”）

- 溢出判断，即判断结果是否溢出

  ![ ](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319185607917.png) 

#### 浮点数的乘除运算（略）



### 算术逻辑单元

#### ALU框图

图中 Ai 和 Bi 为输入变量；ki 为控制信号，ki 的不同取值可决定该电路作哪一种算术运算或哪一种逻辑运算；Fi 是输出函数。

![image-20240319185755884](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319185755884.png) 

---

#### 并行加法器

并行加法器由若千个全加器组成

由于每位全加器的进位输出是高一位全加器的进位输入，因此当全加器有进位时，这种一级一级传递进位的过程将会大大影响运算速度

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319185942199.png" alt="image-20240319185942199" style="zoom:80%;" />  

输入 Ai Bi 输出和为 Si 以及进位 Ci

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319190016253.png" alt="image-20240319190016253" style="zoom:80%;" />  

---

#### 串行进位链

串行进位链是指并行加法器中的进位信号采用串行传递

![image-20240319190402109](https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319190402109.png) 

若设与非门的级延迟时间为ty，那么当di、ti形成后，共需8ty,便可产生最高位的进位。实际上每增加一位全加器，进位时间就会增加2ty，n位全加器的最长进位时间为2nty

---

#### 并行进位链

并行进位链是指并行加法器中的进位信号是同时产生的，又称先行进位、跳跃进位等

##### 单重分组跳跃进位

单重分组跳跃进位就是将位全加器分成若干小组，小组内的进位同时产生，小组与小组之间采用串行进位，这种进位又有组内并行、组间串行之称。

左边的是每组的逻辑电路，左边是串行的组（（小组内并行，小组间串行））

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319190447719.png" alt="image-20240319190447719" style="zoom:50%;" /> <img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319190506553.png" alt="image-20240319190506553" style="zoom:67%;" /> 

---

##### 双重分组跳跃进位

将位全加器分成若干大组，每个大组中又包含若干小组，而每个大组内所包含的各个小组的最高位进位是同时产生的，大组与大组间采用串行进位。

32位并行加法器双重分组跳跃进位链框图（小组间并行，大组间串- 尾数是小数，其位数n反映了浮点数的精度

- 尾数的符号代表浮点数的正负行）

<img src="https://use-typora.oss-cn-hangzhou.aliyuncs.com/image-20240319190538590.png" alt="image-20240319190538590" style="zoom:80%;" />  
